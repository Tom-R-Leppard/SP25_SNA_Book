{
  "hash": "c4e59efa835072ec5f01df4f53daad46",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n\n\n\n\n\n\n\n# Communities In Networks\n\n+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| LEARNING ELEMENTS - Data Practices                                                                                                                                                                                |\n+===================================================================================================================================================================================================================+\n| -   Examining Data Creation. Community detection algorithms provide metrics at the individual and network level of measurement. The community that the individual is in and the modularity of the whole network.  |\n+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(ADAPTSNA)\nlibrary(dplyr)\n```\n:::\n\n\n\n\n\n\n\n\nWithin your network you may have subgroups. In a class of students, there are often smaller homework groups, study groups, friendship groups, etc.. What is the demographic composition of these groups? Do subgroups appear more in some settings compared to others? What happens to these groups over time? To answer these types of questions you need a specific analytic tool, community detection.\n\nAt its core, community detection is a method used to analyse the sub components(groups) of your graph. It literally detects whether there are smaller groups within a network. Using mathematically informed algorithms, various community detection approaches produce measurements of how many sub groups there are in your graph and how cohesive those subgroups are.\n\nFor this tutorial I am using the Grime collaboration network data that we have been using a lot. I am going to bring in the data from 2008 and clean up the graph a bit before we dive in. This network is directed, but for the sake of the tutorial, I bring it in as an undirected graph then swap. You will read why.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrime_edge_list <- load_data(\"GRIME_2008_Edge.csv\", header = TRUE)\ngrime_08 <- graph_from_data_frame(d= grime_edge_list, directed = FALSE)\ngrime_08_clean <- delete.edges(grime_08, E(grime_08)[which_loop(grime_08)])\n```\n:::\n\n\n\n\n\n\n\n\n## The Process\n\nLet's get familiar with how to perform community detection. In this section, I will be using the Louvain algorithm since it is one of the more commonly known and comprehensible. To do so, use the cluster_lourvain() command. Please note, your network may not work with Louvain because it only works with undirected networks (hence why I brought the Grime network in as undirected).\n\nI strongly recommend putting that information into an object. Then we can take a look at what is has in it.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlouv <- cluster_louvain(grime_08_clean)\n\nlouv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH clustering multi level, groups: 17, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Dizzee Rascal\"\n  \n  $`3`\n  [1] \"Lethal Bizzle\"\n  \n  + ... omitted several groups/vertices\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Understanding the Metrics\n\nThe two main things you will want to take from these algorithms are the modularity and the membership. Modularity is a score of how separated, or modular, the network is indicating how cohesive the groups are compared to the whole network. Put simply, modularity measures the density of each group compared to the density inside the group. The statistic is measured from -1/2 to +1 with metrics closer to 1 indicating higher modularity. It is a measurement that compares what we expect to see if the graph were completely random with what is actually observed. Use modularity().\n\nMeanwhile, membership is a vector showing which group each node is classed in. This will come in very handy for you if you want to export this information or use it for visualisations. Use membership().\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodularity(louv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6084184\n```\n\n\n:::\n\n```{.r .cell-code}\nmembership(louv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Asher D   Dizzee Rascal   Lethal Bizzle        Scorcher     Bless Beats \n              1               2               3               1               4 \n        Flowdan  Tinchy Stryder          Frisco            Kano     Treble Clef \n              1               1               1               1               5 \n        Shystie          Blacks         Badness         Chronik         Tempa T \n              6               7               7               7               7 \nNewham Generals          Skepta             JME            Chip             BBK \n              7               7               7               8               4 \nVirus Syndicate          Ghetts        Mercston        Double S        Griminal \n              9              10              11               8               8 \n        Ice Kid Nu Brand Flexxx       Wretch 32           Wiley  Bossman Birdie \n              8              12               8               1              13 \n    The Streets            Sway    Tinie Tempah           Giggs          Jammer \n             14              15              16              17               7 \n      Roll Deep          Devlin        P Money     Lauren Mason     Milli Major \n              4              10               8               1              13 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Visualisation Tips for community detection\n\nThere are two main ways to visualise communities in the network. First is to change the colours of the nodes to match the community they are in. To do this, you utilise the vertex.color() argument in the plot() command\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(0,0,0,0))\nplot(grime_08_clean, vertex.color = louv$membership, vertex.label = NA)\n```\n\n::: {.cell-output-display}\n![](Communities-in-Networks_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\nSecond, you can use polygons to demonstrate the boundaries of the communities. To do this, you plot the clustering object alongside the graph object.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(0,0,0,0))\nplot(louv, grime_08_clean, vertex.label = NA)\n```\n\n::: {.cell-output-display}\n![](Communities-in-Networks_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\nNotice the red edges? Good! This visualisation demonstrates nodes that bridge across communities.\n\nAnother thing to notice is that some of the isolates share colours with others in the network. This is because Rstudio only uses a set number of colours by default. It may be misleading in your report if you include isolates in your network since it appears as if they are in the same community. This is false!!! You may want to clean your network a bit more when presenting these visuals, then.\n\n### Clean your graph\n\nOne main thing you need to think about when detecting communities in your graph is its structure/composition. How your graph is structured might strongly impact the findings you get from your community detection.\n\nIN 2008, there were a lot og Grime artists who did not collaborate with anyone else (isolates). If we were to run a community detection algorithm on the graph with all the isolates still in the graph, they would be included in the algorithms mathematics.\n\nFor example, I am using going to re-run the analysis I did above using the Louvain algorithm with and without the isolates and you will see what a difference it makes visually. To do this, I will delete the isolates from the network and the plot it.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrime_isol <-delete_vertices(grime_08_clean, which(degree(grime_08_clean)==0))\npar(mar = c(0,0,0,0))\nplot(grime_isol)\n```\n\n::: {.cell-output-display}\n![](Communities-in-Networks_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\nNow take the louvain on this network and take a look at it.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlouv_isol <- cluster_louvain(grime_isol)\n\nlouv_isol\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH clustering multi level, groups: 6, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Bless Beats\" \"BBK\"         \"Roll Deep\"  \n  \n  $`3`\n  [1] \"Blacks\"          \"Badness\"         \"Chronik\"         \"Tempa T\"        \n  [5] \"Newham Generals\" \"Skepta\"          \"JME\"             \"Jammer\"         \n  + ... omitted several groups/vertices\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe number of groups has reduced from 17 to 6. This shows that the first algorithm counted the isolates as groups. This becomes even more apparent when we plot the network.\n\nNotice, however, that modularity does not change.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\npar(mar =c(0,0,0,0))\nset.seed(123)\nplot(louv_isol, grime_isol, vertex.label = NA)\nset.seed(123)\nplot(grime_isol, vertex.color = louv_isol$membership, vertex.label = NA)\n```\n\n::: {.cell-output-display}\n![](Communities-in-Networks_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\nNow we do not have the isolates in, it is a much less confusing (noisy) visualisation.\n\n## Comparing algorithms\n\nAs a researcher, you may want to try different algorithms to determine which tells the story of your network. This section shows you four different algorithms. As the scientist, the onus is on you to ensure you understand what the algorithms do and why they may produce slightly different results.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwt <- cluster_walktrap(grime_isol)\nle <- cluster_leading_eigen(grime_isol)\nedge <- cluster_edge_betweenness(grime_isol)\n\npar(mfrow = c(2, 2))\npar(mar =c(0,0,3,0))\nset.seed(123)\nplot(louv_isol, grime_isol, main = \"Louvain\", vertex.label = NA)\nset.seed(123)\nplot(edge, grime_isol, main = \"Edge Betweenness\", vertex.label = NA)\nset.seed(123)\nplot(wt, grime_isol, main = \"Walktrap\", vertex.label = NA)\nset.seed(123)\nplot(le, grime_isol, main = \"Leading Eigenvector\", vertex.label = NA)\n```\n\n::: {.cell-output-display}\n![](Communities-in-Networks_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\nIn this case, we have consensus across multiple algorithms. This is rare, but should build more confidence in your analysis.\n\n## Analysing the communities.\n\nOne thing you can do with the community detection is to describe their nature.A basic example is just to take a look at their characteristics like average the nodal degree in each community to see if certain groups have higher degree than others. In the following chunk, I make a data frame in an object called node data. This data frame has the membership from the louvain algorithm and the nodes' degree. Then, I present a variable (not saved in the dataframe) called mean_degree which presents the mean degree of each community.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode_data <- data.frame(\n  deg = degree(grime_isol),\n  subgroup = louv_isol$membership\n)\n\nnode_data %>%\n     group_by(subgroup) %>%\n     summarise(mean_degree = mean(deg, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 2\n  subgroup mean_degree\n     <dbl>       <dbl>\n1        1        2.12\n2        2        1.67\n3        3        2.12\n4        4        2.17\n5        5        1   \n6        6        1   \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWhat does this new table tell you about each community?\n\nYou can do many different descriptive analyses of these communities. Let's say you have some node-level characteristics like their gender. you can examine the percentage of men/women in each community to see if gender may be associated with one group more than another.\n\n## Final Thoughts\n\nYou need to remember that there are a lot of algorithms that can be used. Each algorithm identifies groups within your network based on a certain characteristic. For example, some algorithms like Louvain seek to maximise the modularity of groups finding the communities that are more densely connected to each other compared to the network as a whole. Meanwhile, Walktrap uses random walks across the graph to determine which nodes occur more frequently together on each others random walk. The co-occurrence of nodes across random walks indicates that they are likely in the same community.\n\nSo, you need to be cautious when selecting what community detection algorithm you are going to use and understand them. When reporting, you will want to report your findings as they relate to the community detection algorithm that you are using otherwise your results could be misleading. For example, if you use the Walktrap but report that the communities are more densely connected to each other than the whole network (clearly a Louvain-related explanation) this may or may not actually be true because Walktrap is not directly measuring community vs. network density.\n\nThe tendency for researchers is to try multiple algorithms and find one that either produces the nicest visualisation, or produces the highest metrics. I strongly recommend not doing this but rather thinking deeply about why there might be differences across measurements. This in itself could be a finding!\n",
    "supporting": [
      "Communities-in-Networks_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}