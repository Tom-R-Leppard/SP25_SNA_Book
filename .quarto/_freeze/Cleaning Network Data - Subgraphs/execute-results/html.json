{
  "hash": "9bda02fd35c582875bf4893b07791764",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n\n\n\n\n\n# Cleaning Network Data - Subgraphs\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(ADAPTSNA)\n```\n:::\n\n\n\n\n\n\nYou may want to create subgraphs of the network that you have. There are two basic ways that you can think about this. You may be interested in a specific group of people and how they relate to each other, or you may be interested in a specific person and find out who they are connected to.\n\n+------------------------------------------------------------------------------------------------------------------------------------------------------+\n| **LEARNING ELEMENTS - Data Discoveries**                                                                                                             |\n+======================================================================================================================================================+\n| -   There are levels of network analysis. Sociocentric networks are the whole group while egocentric networks are the network of an individual.      |\n|                                                                                                                                                      |\n| -   You might have sociocentric network data and discover an interesting story about an individual or a smaller group. For this, you need subgraphs. |\n+------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nFirst, we start by bringing in the data and cleaning out the self loops. This new dataset is of some Grime musicians from Spotify. The nodes are the artists and the ties represent collaborations between the artists.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrime_edge_list <- load_data(\"GRIME_2008_Edge.csv\", header = TRUE)\n\ngrime_08 <- graph_from_data_frame(d= grime_edge_list, directed = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrime_08_clean <- delete_edges(grime_08, E(grime_08)[which_loop(grime_08)])\n```\n:::\n\n\n\n\n\n\n## Specific Subgraphs\n\nFirst, let's talk asume you need a subgraph to see a specific set of people and how/whether they are connected. You may have a list of individual nodes that you are interested in and you want to see how they related to each other. You can do this by creating a vector with the names of those nodes, then use the subgraph function().\n\nWhy might you want to do this? There could be a highly prominent individual, or group of individuals in the network and you might want to see how these individuals are connected.Â Here, the individuals, Wiley, Jammer, Flowdan, and Ice Kid, are some of the older generation grime artists. In this network, taken from 2008, it might be interesting to see how/if these individuals are connected.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub_people <- c('Wiley', 'Jammer', 'Flowdan', 'Ice Kid')\nsub_net <- subgraph(grime_08_clean, sub_people) \npar(mar = c(0,0,0,0))\nplot(sub_net)\n```\n\n::: {.cell-output-display}\n![](Cleaning-Network-Data---Subgraphs_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Ego Graphs\n\nNext, you may want to see ego networks from those in your network. In other words, smaller networks showing only the connections of each individual artist. To do this, you can use the make_ego_graph() argument. This creates a list of ego graphs from your entire network. Note, the order = 1 argument refers to the number of steps away from the ego (focal node). Since mine is set to 1, this only captures the ego's immediate neighbours (i.e. only those directly connected to ego).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nego_graphs <- make_ego_graph(grime_08_clean, order = 1)\nhead(ego_graphs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nIGRAPH 6b33433 DN-- 2 1 -- \n+ attr: name (v/c), collab_weight (e/n)\n+ edge from 6b33433 (vertex names):\n[1] Asher D->Wiley\n\n[[2]]\nIGRAPH 6b33452 DN-- 1 0 -- \n+ attr: name (v/c), collab_weight (e/n)\n+ edges from 6b33452 (vertex names):\n\n[[3]]\nIGRAPH 6b3345e DN-- 1 0 -- \n+ attr: name (v/c), collab_weight (e/n)\n+ edges from 6b3345e (vertex names):\n\n[[4]]\nIGRAPH 6b3346a DN-- 2 1 -- \n+ attr: name (v/c), collab_weight (e/n)\n+ edge from 6b3346a (vertex names):\n[1] Scorcher->Wiley\n\n[[5]]\nIGRAPH 6b33479 DN-- 3 2 -- \n+ attr: name (v/c), collab_weight (e/n)\n+ edges from 6b33479 (vertex names):\n[1] Bless Beats->Wiley     Bless Beats->Roll Deep\n\n[[6]]\nIGRAPH 6b334ae DN-- 3 2 -- \n+ attr: name (v/c), collab_weight (e/n)\n+ edges from 6b334ae (vertex names):\n[1] Flowdan->Wiley  Flowdan->Jammer\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYou can also specify exactly which node's network you want to see. Let's say there was a person of interest in your network that you specifically want to see. To do this, you can do the following using the node's name to single them out.\n\nThis chunk returns a list of edges connected to Wiley (the name of my node of interest).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE(grime_08_clean)[[.inc('Wiley')]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 8/28 edges from 6b2268c (vertex names):\n             tail         head tid hid collab_weight\n1         Asher D        Wiley   1  29             1\n2        Scorcher        Wiley   4  29             4\n3     Bless Beats        Wiley   5  29             1\n4         Flowdan        Wiley   6  29             3\n5  Tinchy Stryder        Wiley   7  29             2\n6          Frisco        Wiley   8  29             1\n7            Kano        Wiley   9  29             1\n27          Wiley Lauren Mason  29  39             1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nI can also plot these. To do so, I make an object with the name 'Wiley' and then make an ego graph based on that name only. The \\[\\[1\\]\\] simply tells R to get only the first one in the list that make_ego_graph() creates. In this case, Wiley. Using the \"order = 1\" option, you are selecting to gather Wiley's immediate neighbours (known as a first order ego network).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nWiley <- \"Wiley\"\nego_wiley <- make_ego_graph(grime_08_clean, order = 1, nodes = Wiley)[[1]]\n\npar(mar = c(0,0,0,0))\nplot(ego_wiley)\n```\n\n::: {.cell-output-display}\n![](Cleaning-Network-Data---Subgraphs_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nThe second order ego network includes the connections of Wiley's neighbours. This is useful to see whether/how Wiley's connections are also collaborating.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecond_order_wiley <- make_ego_graph(grime_08_clean, order = 2, nodes = Wiley)[[1]]\n\npar(mar = c(0,0,0,0))\nplot(second_order_wiley)\n```\n\n::: {.cell-output-display}\n![](Cleaning-Network-Data---Subgraphs_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nPro tip: If you are working with ego networks like this, especially when you get passed the first order network (including friends of friends) it is good practice to do something to differentiate the ego from their neighbours. This way, someone who is looking at the graph can clearly identify who is the ego and who are the neighbours. One simple way it to change their colour.\n\nDon't get too caught up in this code below. We will cover a lot more of this in future chapters (see [Chapter 11](Intermediate%20Visualisation.qmd). What we do here is create a node characteristic called 'ego'. What this characeristic does is assign colours to every node in the network. If the name of that node is \"Wiley\" then the colour is red, otherwise it is white. The next chunk changes the parameters of the plot so we can see it a bit easier. Then, using the vertex.color option of the plot() function, we change the colour of the visualisation to reflect the red and white that we just added.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(second_order_wiley)$ego <- ifelse(V(second_order_wiley)$name %in% c(\"Wiley\"), \"red\", \"white\")\n\npar(mar = c(0,0,3,0))\nplot(second_order_wiley, vertex.color = V(second_order_wiley)$ego, main = \"Wiley's Second Order Ego Network\")\n```\n\n::: {.cell-output-display}\n![](Cleaning-Network-Data---Subgraphs_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nFinally, one other way to can subset a network is by a set parameter you may have. For example, you may want to see a network of frequent collaborators (more than 1 collab).\n\nThe following returns a vector with collaborators who work together more than once.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequent_collabors <- E(grime_08_clean)[[collab_weight > 1]]\nfrequent_collabors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 8/28 edges from 6b2268c (vertex names):\n             tail   head tid hid collab_weight\n2        Scorcher  Wiley   4  29             4\n4         Flowdan  Wiley   6  29             3\n5  Tinchy Stryder  Wiley   7  29             2\n8          Blacks Jammer  12  35             4\n9         Badness Jammer  13  35             5\n11        Tempa T Jammer  15  35             2\n14         Skepta Jammer  17  35             5\n16         Frisco Jammer   8  35             3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYou can then turn this vector of edges into a igraph object to plot.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequent_collabors_graph <- induced_subgraph(grime_08_clean, vids = unique(c(ends(grime_08_clean, frequent_collabors)[, 1], ends(grime_08_clean, frequent_collabors)[, 2])))\nplot(frequent_collabors_graph)\n```\n\n::: {.cell-output-display}\n![](Cleaning-Network-Data---Subgraphs_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Summary\n\nHere we have discussed another method for cleaning network data, taking a subgraph. This is a simple cleaning or transformation tool that allows you to study a subset of your data. We have covered how to take a specific subset based on the names of particular nodes of interest. Alternatively, we can we can create ego networks.\n",
    "supporting": [
      "Cleaning-Network-Data---Subgraphs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}